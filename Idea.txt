Основная мысль:
    Ключевым аспектом построения Event-Driven систем является атомарное сохранение изменения состояния и публикация события, которое описывает это изменение.

Основы:
    - Пользователи хотят работать с надежными системами
    - Если произойдет сбой при сохранении состояния или при публикации события система перейдет в неконсистентное состояние.

Выводы/следствия:
    - Чтобы гарантировать консистентность состояния необходимо понять как этого можно добиться.

Действие:
    - Используйте Oplog напрямую или Change Stream для публикации событий.


5 секунд:
    Операция сохранения изменения состояния и публикации события должна быть атомарной.

1 минута:
    Давайте представим систему, состоящую из двух независимых подсистем. Допустим, в одной подсистеме изменяется состояние. Это изменение состояния нужно сообщить другой подсистеме. Обычно, для того, чтобы сообщить изменение состояния используют специальный вид сообщений - события. Одна подсистема публикует событие в брокер сообщений, а другая подсистема слушает события, которые там появляются, и на них реагирует. Если в первой подсистеме после изменения состояния произойдет сбой и событие не будет опубликовано - вторая подсистема никогда про это событие не узнает. Система окажется в неконсистентном состоянии. Возможно, какой-то критический процесс не будет завершен. Или никогда не начнется. Система будет ненадежна. Чтобы гарантировать надежность системы, операция сохранения изменения состояния и публикации события должна быть атомарной.

10 Минут:
    Прочитав тему доклада и, возможно, аннотацию, вы спросите: "А что же такое Event-Driven система?". Давайте разберемся и определимся с терминами. Представьте себе систему, состоящую из нескольких независимых компонентов или подсистем, которые существуют для решения бизнес-задачи. Чтобы выполнить бизнес-задачу, каждая подсистема должна совершить определенные действия. Каждой из подсистем нужно как-то понимать какое действие и когда нужно совершить. Под Event-Driven системами мы будет понимать такие системы, которые реагируют на изменение состояния системы для выполнения нужного действия. Такие системы еще называют реактивными.

    Возникает вопрос: Как одна подсистема узнает об изменении состояния другой подсистемы? Обычно для этого используют события. Событие - это специальный вид сообщения, которое представляет собой факт изменения состояние системы. У каждого события есть название или тип, который описывает природу изменения, обычно в прошедшем времени. Например, OrderPlaced,  если это какой-то eCommerce домен. Событие содержит минимальный набор данных, чтобы описать изменение состояния. Компонент, в котором происходит изменение состояния публикует событие, которое описывает это изменение в брокер сообщений. Остальные компоненты, которые заинтересованы в этом изменении подписываются на эти события в брокере сообщений и реагируют на них выполняя необходимые действия.

    Давайте представим ситуацию, когда в первой подсистеме после сохранения изменения состояния происходит сбой и не удается опубликовать событие. В таком случае другие подсистемы никогда не узнают об этом событии и бизнес-процесс никогда не завершится. Система окажется в неконсистентном состоянии. Система будет ненадежной. Чтобы гарантировать надежность системы, операция сохранения изменения состояния и публикации события должна быть атомарной.

    Рассмотрим способы атомарно сохранить изменение и опубликовать событие. Сразу оговорюсь, очевидную на первый взгляд Распределенную транзакцию или Two Phase Commit мы не рассматриваем по раду причин. Во-первых, координация транзакций существенно уменьшает пропускную способность системы и поэтому не применима в высоко-нагруженных системах. Во-вторых, многие брокеры сообщений просто не поддерживают распределенные транзакции.

    Наверное, самый простой и гибкий вариант - использовать Event Sourcing. При этом подходе состояние сущности моделируется как набор событий, которые происходили с сущностью. Чтобы восстановить актуальное состояние необходимо поочередно применить все события. При это Event Store - это база данных, специально спроектированная чтобы хранить события. И она в то же время является брокером сообщений. Выходит, изменяя состояние посредством события мы одновременно и публикуем сообщение чем и добиваемся необходимой нам атомарности. Я не буду подробно останавливаться на этой теме, но, если кому-то интересно - найдите меня после доклада, пообщаемся.
    
    Второй вариант часто известен под названием Outbox. Этот подход работает когда хранилище данных поддерживает ACID транзакции между документами или таблицами. Собственно, подходит для всех реляционных баз данных, о которых я знаю. Суть подхода заключается в том, что изменения состояния сущности и событие записываются в базу в одной транзакции. Событие записывается в специальную таблицу, из которой асинхронный процесс потом вычитывает эти события и отправляет в брокер сообщений.

    Третий подход - использование триггеров в базе данных. Триггер срабатывает, когда данные в базе изменяются и он может эти изменения каким-то образом преобразовать в событие и записать в таблицу событий. Недостаток этого подхода в том, что из сырых измененных данных сложно понять и сформировать конкретные типы событий отражающие бизнес-операции.


    
    Обзор реализации на MongoDB